# Instruction

## Requirments

- Docker 
- Golang
- Docker compose 

## Makefile Commands

 `run` *Starts the project*

 `build` *Rebuild the images of the project* 

 `re` *Rebuild the images and starts the project* 

 `test` *Run all the tests* 

## Directory and File Descriptions

### `/env`
- **Functions related to the environment of my program, including retrieving current environment**

### `/models`
- **various model structures used in the application, including database models, request models, and response models.**

### `/query`
- **Functions related to the database**

### `/server`
- **Start function function for initializing the server, including the setup of the API router**

### `/service`
- **core functions of my API**

### Root Files
- **`Dockerfile`**: Docker configuration file for building the application image.
- **`docker-compose.yml`**: Docker Compose configuration for orchestrating multi-container environments.
- **`go.mod`**: Go module file specifying dependencies.
- **`go.sum`**: Go checksum file for dependency verification.
- **`README.md`**: Documentation for the project, including setup instructions and usage information.
- **`API.md`**: API Documentation.
- **`main.go`**: The entry point for the application. It initializes the application and starts the HTTP server.

## Technology Choices

I have chosen PostgreSQL as the database with the GORM library. This is a suitable choice for our project, as it facilitates linking media elements with tags through relational data. PostgreSQL allows us to create joins between our tables, making it easier to manage and query interconnected data. Additionally, PostgreSQL supports storing media files directly in the database, which can be beneficial for certain use cases.

To streamline project deployment, I am using Docker along with Docker Compose. Docker simplifies the deployment process by creating isolated environments for our applications, while Docker Compose makes it easy to set up and manage multi-container Docker applications. By using Docker Compose, you can create a local PostgreSQL database that allows you to run and test the project on your own machine.

For the web framework, I have selected Gin Gonic. Gin Gonic is one of the most popular and efficient web frameworks for the Go programming language. It provides a fast and flexible framework for building web applications, making it a great fit for our project's needs.

For testing purposes, I am using Testcontainers. This tool allows me to spin up PostgreSQL containers directly from my tests, which is ideal for integration testing. Testcontainers provides a convenient way to manage test dependencies and ensures that the database environment is consistent and isolated for each test run.

## Design

```go
type Tag struct {
    ID   uint   `gorm:"primaryKey"`
    Name string `gorm:"not null"`
}
```

- ID: The primary key of the Tag struct, used to uniquely identify each tag. It is of type uint.
- Name: A string representing the name of the tag. It cannot be null (gorm:"not null").

```go
type Media struct {
    ID        string  `gorm:"primaryKey;default:uuid_generate_v4()"`
    Name      string  `gorm:"not null"`
    File      []byte  `gorm:"type:bytea"`
    Extension string  `gorm:"not null"`
    Tags      []Tag   `gorm:"many2many:tag_media;"`
}
```

- ID: The primary key of the Media struct, which is a string. It has a default value generated by the uuid_generate_v4() function.
- Name: A string representing the name of the media. It cannot be null (gorm:"not null").
- File: A byte slice ([]byte) representing the media file. It is stored in a column of type bytea in PostgreSQL.
- Extension: A string representing the file extension of the media. It cannot be null (gorm:"not null").
- Tags: A many-to-many relationship with the Tag struct. This is defined using GORM's many2many relationship, and it uses the tag_media join table to manage the associations.

- Many-to-Many Relationship: The Media struct has a many-to-many relationship with the Tag struct. This means that a single media item can be associated with multiple tags, and a single tag can be associated with multiple media items. The relationship is managed through a join table named tag_media.

## Possible Improvments 

We need to account for the potential future volume of media and tags in our application. In the case of a high volume of media/tags, some technical improvements may be necessary.

1. Pagination on Requests: We could implement pagination on our current API requests that return arrays. This would simplify the integration of the API and manage large datasets more efficiently.

2. External File Storage: Currently, files are stored directly in the database. To limit database size, we could implement a cloud storage solution, such as AWS S3 or Google Cloud Storage.

3. Image Compression: Implementing image compression before storing images can help reduce their size and manage storage more effectively.

4. Presigned URLs for Public Images: Use cloud providers' presigned URLs and store these URLs in our database for images that are public. This approach will help in managing image access and reduce the load on our database.
